#,Issue,Detailed Problem,Proposed Solution,Action Steps
1,Multiple Context Providers,"There are at least two React Contexts handling similar logic (e.g., auth state, global UI settings), and they are nested within each other. This causes unnecessary re-renders, as any change in context value re-renders all consuming components unless you memoize selectors manually.","Combine the overlapping Contexts into one; Replace Context with Zustand, which allows selective subscriptions to avoid full tree re-renders.",Identify overlapping logic between the contexts; Migrate shared logic into one central store (Zustand or context + selector pattern); Replace existing useContext usages carefully to avoid regressions
2,API Calls in useEffect Trigger Chained Effects,"Some components perform data fetching in useEffect, and other components react to the fetched data using their own useEffect. This causes chained and redundant effects, especially when data is reused across components.",Audit all useEffect hooks that depend on fetched data; Combine similar API calls; Avoid triggering other useEffects unnecessarily; Consider lifting the data-fetching responsibility to a higher level or global store.,Trace components that depend on the same API response; Merge or lift API calls into a parent or shared hook; Use conditionals inside useEffect to prevent redundant triggers
3,All Components Render on Screen Load,"On initial screen load, all organism-level components mount immediately, even those not visible on screen (e.g., tabs, collapsibles, dynamic views). Each of them fires its own useEffect, leading to a burst of expensive operations at once.",Use React.lazy and Suspense for code splitting and deferring component load; Lazy-load invisible components or move to dynamic import strategy; Optionally preload them in the background.,"Identify non-critical, off-screen, or conditionally visible components; Wrap them with lazy(() => import(...)); Use <Suspense fallback={...}> to display loaders or placeholders"
4,Redundant State Derived from Props,"State like const [data, setData] = useState(dataSource) is created even though data is never modified independently â€” only set from props. This leads to double state management, extra memory, and unnecessary re-renders.","Avoid local state unless modification is needed; Pass dataSource directly to child components like <DataTable dataSource={...} />; If memoization is needed, use useMemo.","Search for state variables whose only purpose is copying props; Remove local useState and use props directly; Add memoization only where needed (e.g., for computed values)"
5,Unstable References in Dependency Arrays,"Some useEffect hooks may depend on functions or objects that are re-created on every render, unintentionally retriggering the effect. This causes subtle re-render issues and bugs.",Use useCallback for functions; Use useMemo for derived objects/arrays; Ensure dependencies are stable to avoid unintended re-runs.,"Audit all useEffect, useMemo, and useCallback hooks; Refactor unstable functions passed as dependencies; Ensure custom hooks return stable values when needed"
