// MyComponent.tsx
import React, { useRef, useEffect, useState, useCallback } from 'react';

// this tells the bundler “treat this TS file as a worker module”
const workerURL = new URL('./stateWorker.ts', import.meta.url);

const MyComponent = () => {
  const [globalState, setGlobalState] = useState<IGlobalState>({ /* … */ loading: false });
  const workerRef = useRef<Worker>();

  useEffect(() => {
    // note the `{ type: 'module' }` so it can import/export
    workerRef.current = new Worker(workerURL, { type: 'module' });
    workerRef.current.onmessage = (e: MessageEvent<{ key: string; value: any }>) => {
      const { key, value } = e.data;
      setGlobalState(prev => ({ ...prev, [key]: value, loading: false }));
    };
    return () => workerRef.current?.terminate();
  }, []);

  const setGlobalStateByKey = useCallback((key: string, value: any) => {
    setGlobalState(prev => ({ ...prev, loading: true }));
    workerRef.current?.postMessage({ key, value });
  }, []);

  // …
};











// stateWorker.ts
// NOTE: this runs in a Web Worker context

type MsgIn  = { key: string; value: any };
type MsgOut = { key: string; value: any };

self.onmessage = (e: MessageEvent<MsgIn>) => {
  const { key, value } = e.data;

  // (optional) do any expensive transformation here,
  // e.g. sorting/filtering huge arrays, etc.
  // const processed = heavyCompute(value);

  // For now we just pass it straight through:
  const processed = value;

  // post back the result
  (self as any).postMessage({ key, value: processed } as MsgOut);
};
