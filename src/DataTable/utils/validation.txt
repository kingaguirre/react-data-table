import React, { useState, useRef, useEffect, useCallback } from 'react';
import StateWorker from './stateWorker.ts'; // assuming you have bundler support for workers

const MyComponent = (props) => {
  const [globalState, setGlobalState] = useState<IGlobalState>({
    /* … your initial state … */,
    loading: false,
  });

  // keep a ref to the worker so we don’t recreate it every render
  const workerRef = useRef<Worker>();

  // initialize worker once
  useEffect(() => {
    workerRef.current = new StateWorker();
    workerRef.current.onmessage = (e: MessageEvent<{ key: string; value: any }>) => {
      const { key, value } = e.data;
      // merge in the processed value and turn off loading
      setGlobalState(prev => ({
        ...prev,
        [key]: value,
        loading: false,
      }));
    };
    return () => {
      workerRef.current?.terminate();
    };
  }, []);

  // updated setter that uses the worker
  const setGlobalStateByKey = useCallback((key: string, value: any) => {
    // flip on loading
    setGlobalState(prev => ({ ...prev, loading: true }));
    // send work to the worker
    workerRef.current?.postMessage({ key, value });
  }, []);

  // likewise for bulk updates
  const setGlobalStateByObj = useCallback((newValues: Record<string, any>) => {
    setGlobalState(prev => ({ ...prev, loading: true }));
    // if you want to batch them, send each key individually:
    Object.entries(newValues).forEach(([key, value]) =>
      workerRef.current?.postMessage({ key, value })
    );
  }, []);

  // … your component render …
  return (
    <>
      {globalState.loading && <div className="spinner">Updating…</div>}
      {/* rest of your UI */}
    </>
  );
};











// stateWorker.ts
// NOTE: this runs in a Web Worker context

type MsgIn  = { key: string; value: any };
type MsgOut = { key: string; value: any };

self.onmessage = (e: MessageEvent<MsgIn>) => {
  const { key, value } = e.data;

  // (optional) do any expensive transformation here,
  // e.g. sorting/filtering huge arrays, etc.
  // const processed = heavyCompute(value);

  // For now we just pass it straight through:
  const processed = value;

  // post back the result
  (self as any).postMessage({ key, value: processed } as MsgOut);
};
