import React, { useRef, Fragment, useMemo } from "react";
import { TXInput, CODE_DECODE_DROPDOWN } from '@atoms/TXInput';
import { TXAmount } from '@atoms/TXAmount';
import * as SC from "./styled";
import 'tippy.js/dist/tippy.css';
import 'tippy.js/themes/light.css';
import 'tippy.js/themes/material.css';
import Tippy from '@tippyjs/react';
import {
  getDeepValue,
  highlightText,
  mergeCustomStylesForRow,
  getValue,
  useCheckOverflow,
  useTXAjvValidation,
  getTableCellClass,
  getErrorMessage,
  checkMinLength,
  FIELD_REQUIRED,
  getTypedCellValue,
  isCurrencyObjFormat,
  getParsedValue,
  getSchemaObjValue,
  renderColumnCustomRenderer,
  DATA_UNIQUE_TEXT,
  // Importing getIsDuplicate so we use its exact logic
  getIsDuplicate,
} from "../../../utils";
import {
  getTitle,
  isAutoHeightTableCell
} from './utils';
import { Actions } from "../../../interfaces";
import { useValidationMessage } from "@atoms/../hooks";
import { withState, IComponent } from '../../../GlobalStateProvider';

export const Cell = withState({
  states: [
    'rowKey',
    'customRowSettings',
    'columns',
    'search',
    'editingCells',
    'hasAction',
    'selectedCell',
    'showPreviousValue',
    'selectionRangeRef',
    'handleDoCellEdit',
    'handleDoCellEditOnChange',
    'overrideUpdateStyle',
    'highlightedCell',
  ],
})(React.memo((props: IComponent) => {
  const {
    rowKey,
    customRowSettings,
    columns,
    search,
    editingCells,
    hasAction,
    selectedCell,
    showPreviousValue,
    selectionRangeRef,
    setGlobalStateByKey,
    setGlobalState,

    // Props related to a cell
    column,
    columnKey,
    columnIndex,
    row,
    rowIndex,
    cellRefs,
    rowKeyValue,
    dataSource,
    pinnedStyle,
    isPinned,
    checkIsNewRow,
    overrideUpdateStyle
  } = props;

  const cellRef = cellRefs?.current[`${rowKeyValue}-${columnKey}`];
  const { getTranslatedMessage } = useValidationMessage();
  const { addElement, ellipsisMap } = useCheckOverflow();
  const cellKey = `row-${rowKeyValue}-col-${columnKey}`;
  const hasEllipsis = ellipsisMap.get(cellKey);

  const customRowStyle = mergeCustomStylesForRow(row, customRowSettings);
  const isUpdatedRow = getDeepValue(row, "intentAction") === "U";
  const isDeletedRow = getDeepValue(row, "intentAction") === "D";
  const isNewRow = checkIsNewRow(row);
  const _hasOldValue = getDeepValue(row, `${columnKey?.replace('.value', '')}.previous.value`, true);

  // Compute validation once per render using useMemo.
  // This logic now mirrors what was in isColumnValid and uses getIsDuplicate.
  const validation = useMemo(() => {
    const _rowKeyValue = getDeepValue(row, rowKey);
    const cellValue = getDeepValue(row, column.column) || column?.actionConfig?.value;
    let isValid = true;
    let errorMessage = "";

    // Locate the editing cell in case the user is in the process of editing.
    const _editingCell = editingCells.find(
      cell => cell.rowKeyValue === _rowKeyValue && cell.column === column.column
    );
    const isInEditableStatus = !!(_editingCell && _editingCell.editable);

    // If a custom renderer is used or the cell is actively being edited,
    // skip duplicate and schema validations.
    if (column.columnCustomRenderer || isInEditableStatus) {
      return { isValid, errorMessage };
    }

    // -- Unique/Duplicate Validation --
    if (column?.actionConfig?.isUnique) {
      const parsedValue = getParsedValue(cellValue, column);
      if (parsedValue !== undefined) {
        // Use getIsDuplicate to check the dataSource.
        const duplicateFound = getIsDuplicate(dataSource, parsedValue, column.column, rowKey, _rowKeyValue);
        if (duplicateFound) {
          isValid = false;
          errorMessage = DATA_UNIQUE_TEXT;
        }
      }
    }

    // If the editing cell is flagged invalid, use its error.
    if (_editingCell?.invalid && isInEditableStatus) {
      isValid = false;
      errorMessage = _editingCell.error;
    }

    // -- Schema Validation --
    if (column?.actionConfig?.schema && isValid) {
      const parsedValue = getParsedValue(cellValue, column);
      const isRequired = checkMinLength(column?.actionConfig?.schema) && !parsedValue;
      if (isRequired) {
        isValid = false;
        errorMessage = FIELD_REQUIRED;
      } else {
        const validationErrors = useTXAjvValidation(
          getSchemaObjValue(parsedValue, column),
          column?.actionConfig?.schema
        );
        if (validationErrors) {
          isValid = false;
          errorMessage = getErrorMessage(validationErrors, column.title, getTranslatedMessage);
        }
      }
    }

    return { isValid, errorMessage };
  }, [row, column, dataSource, editingCells, rowKey, getTranslatedMessage]);

  // The rest of your cell rendering logic stays largely the same.
  const handleKeyDown = (_row, _column) => (e) => {
    if (e.key === "Enter") {
      // ... handle Enter key
    } else if (e.key === "Escape") {
      // ... handle Escape key
    }
  };

  const handleCellChange = (newValue, rowKeyValue, columnKey) => {
    setGlobalState(prev => {
      const cellIndex = prev.editingCells.findIndex(
        cell => cell.rowKeyValue === rowKeyValue && cell.column === columnKey
      );

      if (cellIndex !== -1) {
        const newCells = [...prev.editingCells];
        newCells[cellIndex] = { ...newCells[cellIndex], value: newValue };
        return {
          ...prev,
          editingCells: newCells
        };
      }
      return {
        ...prev,
        editingCells: [...prev.editingCells, { rowKeyValue, column, value: newValue }]
      };
    });
  };

  const handleEditOnChange = (value, _row, _column) => {
    // ... handle onChange in edit
  };

  const getInputs = (_column, _editingCell) => {
    const { actionConfig } = _column || {};
    const { type, text, placeholder, multiSelect, codeId, disabled } = actionConfig || {};
    const isInvalid = _editingCell?.invalid;
    const error = _editingCell?.error;

    switch (true) {
      case type === "text" || type === "number" || !type:
        return (
          <TXInput
            size="xs"
            rawValueOnChange
            type={type || "text"}
            placeholder={placeholder}
            value={_editingCell.value}
            onChange={(e) => handleCellChange(e, rowKeyValue, column.column)}
            onKeyDown={handleKeyDown(row, _column)}
            variation={isInvalid ? "danger" : undefined}
            helpText={error || undefined}
            showPreviousValue={false}
            onBlur={() => {/* trigger cell edit completion */}}
            disabled={typeof disabled === "function" ? disabled(row) : disabled}
          />
        );
      // ... other input types (dropdown, date, checkbox, etc.) remain the same.
      default:
        return null;
    }
  };

  const getCellContent = (_column) => {
    const { columnCustomRenderer, type } = _column || {};
    const cellValue = getDeepValue(row, _column.column);

    const _rowKeyValue = getDeepValue(row, rowKey);
    const _editingCell = editingCells.find(
      cell => cell.rowKeyValue === _rowKeyValue && cell.column === _column.column
    );
    const isInEditableStatus = !!(_editingCell && _editingCell.editable);

    if (isInEditableStatus && !columnCustomRenderer && !(
      // Check if non-editable due to other conditions
      (editingCells?.some(i => i?.isNew) || dataSource?.find(i => i.intentAction === '*')) &&
      getDeepValue(row, "intentAction") !== "*"
    )) {
      return getInputs(_column, _editingCell);
    } else {
      if (columnCustomRenderer) {
        return renderColumnCustomRenderer(columnCustomRenderer(cellValue, row));
      } else {
        if (typeof cellValue === "object" && cellValue !== null) {
          return JSON.stringify(cellValue);
        } else {
          if (cellValue !== "null") {
            return type ? getTypedCellValue(cellValue, type) : getValue(cellValue);
          }
          return "";
        }
      }
    }
  };

  const getHighlightedCellContent = (cellContent, _column, _search) => {
    if (_search) {
      const { columnCustomRenderer } = _column || {};
      const isCustomCell = columnCustomRenderer && typeof cellContent !== 'string';
      if (search && !isCustomCell) {
        return highlightText(cellContent, search);
      }
    }
    return cellContent;
  };

  const handleCellClick = (e, _column, _row) => {
    e.stopPropagation();
    const columnValue = _column.column;
    const cellValue = getDeepValue(row, columnValue);
    const parsedValue = getParsedValue(cellValue, _column);
    const value = (parsedValue !== "null" && parsedValue !== null) ? parsedValue : "";

    selectionRangeRef?.current?.clearSelection();

    const isEditingCellsExist = editingCells.find(i => i.rowKeyValue === rowKeyValue && i.column === columnValue);
    const newEditingCells = isEditingCellsExist ? [...editingCells]
      .map(i => i.rowKeyValue === rowKeyValue && i.column === columnValue ? ({
        ...i,
        value,
        editable: true,
      }) : i) :
      [...editingCells, {
        rowKeyValue,
        value,
        column: columnValue,
        type: _column?.actionConfig?.type,
        editable: true
      }];

    setGlobalStateByKey('editingCells', newEditingCells);
    setGlobalStateByKey('selectedCell', { rowKeyValue, column: columnValue });
  };

  const isCustomCell = column.columnCustomRenderer && typeof getCellContent(column) !== 'string';

  return !column.hidden ? (
    <Fragment>
      <SC.TableCell
        ref={cellRef}
        width={column?.width || column.defaultWidth}
        minWidth={column?.minWidth}
        align={isCurrencyObjFormat('cellValue') ? "right" : column.align}
        isPinned={isPinned}
        style={{
          ...pinnedStyle,
          ...((isUpdatedRow && customRowSettings && !overrideUpdateStyle) ? {
            backgroundColor: (_hasOldValue && showPreviousValue) ? "#FFE380" : "white"
          } : customRowStyle),
          ...(((editingCells.some(i => i.rowKeyValue === rowKeyValue && i.column === column.column) &&
              isAutoHeightTableCell(column)) || isCustomCell) ? { height: "auto" } : {})
        }}
        {...((isCustomCell || editingCells.some(i => i.rowKeyValue === rowKeyValue && i.column === column.column)) ? {} : {
          onClick: (e) => handleCellClick(e, column, row)
        })}
        className={getTableCellClass({
          isInEditableStatus: editingCells.some(i => i.rowKeyValue === rowKeyValue && i.column === column.column),
          isSelectedCell: selectedCell?.rowKeyValue === rowKeyValue && selectedCell?.column === column.column,
          hasEditAction: hasAction(Actions.EDIT),
          isCellEditable: !isDeletedRow,
          noActionConfig: column?.actionConfig === false,
          column,
          highlighted: false  // or your highlighted condition
        })}
        data-row-index={rowIndex}
        data-column-index={columnIndex}
        data-column={column.column}
        data-disable-selection={column.disableSelection}
        data-disable-copy={column.disableCopy || !!column.columnCustomRenderer}
        data-disable-paste={column?.actionConfig === false || isDeletedRow}
        data-column-name={column.title}
      >
        <SC.CellContent
          className={`cell-content ${isCustomCell ? 'is-custom-cell' : ''}`}
          isCustomCell={isCustomCell || editingCells.some(i => i.rowKeyValue === rowKeyValue && i.column === column.column)}
          style={{ maxWidth: column?.width }}
          ref={node => addElement(node, cellKey)}
          title={columnKey === 'intentAction' ? getTitle(row) : ''}
        >
          {getHighlightedCellContent(getCellContent(column), column, search)}
        </SC.CellContent>
        <ColumnDragHighlighter index={columnIndex} />
        {column.resizable !== false && <SC.ResizeHandle className="resize-handle" />}
        {(!validation.isValid && !isDeletedRow) && (
          <Tippy
            content={
              <SC.InvalidToolTip>
                {validation.errorMessage}
              </SC.InvalidToolTip>
            }
            placement="top"
            theme="light"
          >
            <SC.InvalidBorder />
          </Tippy>
        )}
      </SC.TableCell>
      {(hasEllipsis && !editingCells.some(i => i.rowKeyValue === rowKeyValue && i.column === column.column) && !isCustomCell) && (
        <Tippy content={getCellContent(column)} placement="bottom" reference={cellRef} />
      )}
      {!!(_hasOldValue && !editingCells.some(i => i.rowKeyValue === rowKeyValue && i.column === column.column) && showPreviousValue) && (
        <Tippy
          content={`Previous Value: ${_hasOldValue}`}
          placement="top"
          theme="light"
          reference={cellRef}
        />
      )}
    </Fragment>
  ) : null;
}));

export const ColumnDragHighlighter = withState({
  states: [
    'dropTargetIndex',
    'draggedColumnIndex',
  ],
})(React.memo((props: IComponent) => {
  const { index, dropTargetIndex, draggedColumnIndex } = props;

  return (dropTargetIndex === index || draggedColumnIndex === index) ? (
    <SC.ColumnDragHighlighter className="column-drag-highlighter" isDraggedColumn={draggedColumnIndex === index} />
  ) : null;
}));

export const getIsDuplicate = (dataSource, value, column, rowKey, rowKeyValue) => {
  return dataSource.some((_row) => {
    const rowValue = getDeepValue(_row, column);
    const _rowKeyValueLocal = getDeepValue(_row, rowKey);
    const isDeletedRow = getDeepValue(_row, "intentAction") === "D";
    return (_rowKeyValueLocal !== rowKeyValue &&
      getValue(rowValue)?.toString()?.trim()?.toLowerCase() === value?.toString()?.trim()?.toLowerCase()) && !isDeletedRow;
  });
};
